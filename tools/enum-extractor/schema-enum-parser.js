#!/usr/bin/env node

const fs = require('fs');
const yaml = require('js-yaml');
const path = require('path');

/**
 * SQL Schema Enum Parser for Supabase CLI Generated Schema Dumps
 * 
 * Parses SQL schema dumps generated by `supabase db dump` and extracts
 * enum definitions from CHECK constraints for Supadart configuration.
 * 
 * Usage:
 *   node schema-enum-parser.js <schema-file> [config-path]
 */

function parseSchemaEnums(schemaFilePath, configPath = 'supadart.yaml') {
  console.log('ğŸ” Parsing SQL schema for enum definitions...');
  
  if (!fs.existsSync(schemaFilePath)) {
    throw new Error(`Schema file not found: ${schemaFilePath}`);
  }
  
  const schemaContent = fs.readFileSync(schemaFilePath, 'utf8');
  console.log(`ğŸ“– Read SQL schema from: ${schemaFilePath}`);
  
  const enums = {};
  
  // Parse CHECK constraints that define enum-like values
  // Look for patterns like: CHECK ((column = ANY (ARRAY['value1'::text, 'value2'::text, ...])))
  // or: CHECK (column IN ('value1', 'value2', ...))
  
  // Match CREATE TABLE statements with CHECK constraints
  const tableMatches = schemaContent.matchAll(/CREATE TABLE[^;]*?(\w+)\s*\(([\s\S]*?)\);/gi);
  
  for (const tableMatch of tableMatches) {
    const [, tableName, tableDefinition] = tableMatch;
    
    // Find CHECK constraints within the table definition
    const checkConstraints = tableDefinition.matchAll(/CONSTRAINT\s+\w+\s+CHECK\s*\((.*?)\)/gi);
    
    for (const checkMatch of checkConstraints) {
      const [, constraintClause] = checkMatch;
      
      // Parse ARRAY[...] format: ((column = ANY (ARRAY['value1'::text, 'value2'::text, ...])))
      const arrayMatch = constraintClause.match(/\(?\(?(\w+)\)?.*?=.*?ANY\s*\(\s*ARRAY\[([^\]]+)\]\s*\)/i);
      if (arrayMatch) {
        const [, columnName, valuesString] = arrayMatch;
        const values = [];
        
        // Extract quoted values from the ARRAY
        const valueMatches = valuesString.matchAll(/'([^']+)'::text/g);
        for (const valueMatch of valueMatches) {
          values.push(valueMatch[1]);
        }
        
        if (values.length > 1) {
          // Handle conflicts by taking the most comprehensive enum
          if (enums[columnName]) {
            if (values.length > enums[columnName].length) {
              console.log(`  ğŸ”„ ${columnName}: [${values.join(', ')}] (updated - more comprehensive)`);
              enums[columnName] = values;
            } else {
              console.log(`  âš ï¸ ${columnName}: [${values.join(', ')}] (skipped - less comprehensive)`);
            }
          } else {
            enums[columnName] = values;
            console.log(`  ğŸ“ ${columnName}: [${values.join(', ')}] (from ${tableName})`);
          }
        }
        continue;
      }
      
      // Parse IN(...) format: CHECK (column IN ('value1', 'value2', ...))
      const inMatch = constraintClause.match(/\(?\(?(\w+)\)?.*?IN\s*\(\s*([^)]+)\s*\)/i);
      if (inMatch) {
        const [, columnName, valuesString] = inMatch;
        const values = [];
        
        // Extract quoted values from the IN clause
        const valueMatches = valuesString.matchAll(/'([^']+)'/g);
        for (const valueMatch of valueMatches) {
          values.push(valueMatch[1]);
        }
        
        if (values.length > 1) {
          // Handle conflicts by taking the most comprehensive enum
          if (enums[columnName]) {
            if (values.length > enums[columnName].length) {
              console.log(`  ğŸ”„ ${columnName}: [${values.join(', ')}] (updated - more comprehensive)`);
              enums[columnName] = values;
            } else {
              console.log(`  âš ï¸ ${columnName}: [${values.join(', ')}] (skipped - less comprehensive)`);
            }
          } else {
            enums[columnName] = values;
            console.log(`  ğŸ“ ${columnName}: [${values.join(', ')}] (from ${tableName})`);
          }
        }
      }
    }
    
    // Also check for inline CHECK constraints in column definitions
    const columnMatches = tableDefinition.matchAll(/(\w+)\s+[^,\n]+CHECK\s*\((.*?)\)/gi);
    for (const columnMatch of columnMatches) {
      const [, columnName, constraintClause] = columnMatch;
      
      // Parse various CHECK constraint formats
      const arrayMatch = constraintClause.match(/\(?(\w+)\)?.*?=.*?ANY\s*\(\s*ARRAY\[([^\]]+)\]\s*\)/i);
      if (arrayMatch) {
        const [, , valuesString] = arrayMatch;
        const values = [];
        
        const valueMatches = valuesString.matchAll(/'([^']+)'::text/g);
        for (const valueMatch of valueMatches) {
          values.push(valueMatch[1]);
        }
        
        if (values.length > 1) {
          if (enums[columnName]) {
            if (values.length > enums[columnName].length) {
              console.log(`  ğŸ”„ ${columnName}: [${values.join(', ')}] (updated from inline constraint)`);
              enums[columnName] = values;
            }
          } else {
            enums[columnName] = values;
            console.log(`  ğŸ“ ${columnName}: [${values.join(', ')}] (from inline constraint)`);
          }
        }
      }
    }
  }
  
  // Also look for standalone CHECK constraints added via ALTER TABLE
  const alterMatches = schemaContent.matchAll(/ALTER TABLE[^;]*?(\w+)[^;]*?ADD CONSTRAINT[^;]*?CHECK\s*\((.*?)\);/gi);
  for (const alterMatch of alterMatches) {
    const [, tableName, constraintClause] = alterMatch;
    
    const arrayMatch = constraintClause.match(/\(?(\w+)\)?.*?=.*?ANY\s*\(\s*ARRAY\[([^\]]+)\]\s*\)/i);
    if (arrayMatch) {
      const [, columnName, valuesString] = arrayMatch;
      const values = [];
      
      const valueMatches = valuesString.matchAll(/'([^']+)'::text/g);
      for (const valueMatch of valueMatches) {
        values.push(valueMatch[1]);
      }
      
      if (values.length > 1) {
        if (enums[columnName]) {
          if (values.length > enums[columnName].length) {
            console.log(`  ğŸ”„ ${columnName}: [${values.join(', ')}] (updated from ALTER TABLE)`);
            enums[columnName] = values;
          }
        } else {
          enums[columnName] = values;
          console.log(`  ğŸ“ ${columnName}: [${values.join(', ')}] (from ALTER TABLE)`);
        }
      }
    }
  }
  
  console.log(`ğŸ“Š Found ${Object.keys(enums).length} enum definitions`);
  
  // Read existing config or create basic template
  let config = {};
  if (fs.existsSync(configPath)) {
    console.log(`ğŸ“– Reading existing config: ${configPath}`);
    config = yaml.load(fs.readFileSync(configPath, 'utf8'));
  } else {
    console.log(`ğŸ“„ Creating new config: ${configPath}`);
    config = {
      supabase_url: process.env.SUPABASE_URL || 'YOUR_SUPABASE_URL',
      supabase_anon_key: process.env.SUPABASE_ANON_KEY || 'YOUR_SUPABASE_ANON_KEY',
      dart_format: true,
      output: '.',
      separated: true,
      dart_class: true,
      include_views: true,
      include_enums: true
    };
  }
  
  // Update enums section
  config.enums = enums;
  
  // Write updated config
  const configDir = path.dirname(configPath);
  if (!fs.existsSync(configDir)) {
    fs.mkdirSync(configDir, { recursive: true });
  }
  
  fs.writeFileSync(configPath, yaml.dump(config, {
    flowLevel: 2,
    quotingType: '"',
    forceQuotes: false
  }));
  
  console.log(`âœ… Updated Supadart config with ${Object.keys(enums).length} enum types`);
  console.log(`ğŸ“ Config saved to: ${configPath}`);
  
  return enums;
}

// CLI execution
if (require.main === module) {
  const schemaFilePath = process.argv[2];
  const configPath = process.argv[3] || 'supadart.yaml';
  
  if (!schemaFilePath) {
    console.error('Usage: node schema-enum-parser.js <schema-file> [config-path]');
    process.exit(1);
  }
  
  try {
    const enums = parseSchemaEnums(schemaFilePath, configPath);
    console.log('\nğŸ‰ Schema enum parsing completed successfully!');
    console.log(`ğŸ“Š Total enums: ${Object.keys(enums).length}`);
    process.exit(0);
  } catch (error) {
    console.error('\nğŸ’¥ Schema enum parsing failed:', error.message);
    process.exit(1);
  }
}

module.exports = { parseSchemaEnums };