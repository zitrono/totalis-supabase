#!/usr/bin/env node

const fs = require('fs');
const yaml = require('js-yaml');
const path = require('path');

/**
 * TypeScript Enum Parser for Supabase CLI Generated Types
 * 
 * Parses TypeScript types generated by `supabase gen types typescript`
 * and extracts enum definitions for Supadart configuration.
 * 
 * Usage:
 *   node typescript-enum-parser.js <types-file> [config-path]
 */

function parseTypescriptEnums(typesFilePath, configPath = 'supadart.yaml') {
  console.log('üîç Parsing TypeScript types for enum definitions...');
  
  if (!fs.existsSync(typesFilePath)) {
    throw new Error(`TypeScript types file not found: ${typesFilePath}`);
  }
  
  const typesContent = fs.readFileSync(typesFilePath, 'utf8');
  console.log(`üìñ Read TypeScript types from: ${typesFilePath}`);
  
  const enums = {};
  
  // Parse Database type interfaces for enum-like union types
  // Look for patterns like: column_name: "value1" | "value2" | "value3"
  const enumPatterns = [
    // Match interface properties with union types
    /(\w+):\s*"([^"]+)"\s*(?:\|\s*"([^"]+)"\s*)*/g,
    // Match type aliases with union types  
    /type\s+(\w+)\s*=\s*"([^"]+)"\s*(?:\|\s*"([^"]+)"\s*)*/g
  ];
  
  // Extract enum-like union types from Database interfaces
  const databaseMatch = typesContent.match(/export interface Database\s*{[\s\S]*?^}/m);
  if (databaseMatch) {
    const databaseContent = databaseMatch[0];
    
    // Look for Tables section
    const tablesMatch = databaseContent.match(/Tables:\s*{([\s\S]*?)}/);
    if (tablesMatch) {
      const tablesContent = tablesMatch[1];
      
      // Extract individual table definitions
      const tableMatches = tablesContent.match(/(\w+):\s*{[\s\S]*?}/g);
      if (tableMatches) {
        tableMatches.forEach(tableMatch => {
          // Look for Row or Insert types within each table
          const rowMatch = tableMatch.match(/Row:\s*{([\s\S]*?)}/);
          if (rowMatch) {
            const rowContent = rowMatch[1];
            
            // Find union type properties (potential enums)
            const unionMatches = rowContent.matchAll(/(\w+):\s*([^;]+);/g);
            for (const match of unionMatches) {
              const [, columnName, typeDefinition] = match;
              
              // Check if it's a union type with string literals
              if (typeDefinition.includes('|') && typeDefinition.includes('"')) {
                const values = [];
                const valueMatches = typeDefinition.matchAll(/"([^"]+)"/g);
                for (const valueMatch of valueMatches) {
                  values.push(valueMatch[1]);
                }
                
                if (values.length > 1) {
                  // Handle conflicts by taking the most comprehensive enum
                  if (enums[columnName]) {
                    if (values.length > enums[columnName].length) {
                      console.log(`  üîÑ ${columnName}: [${values.join(', ')}] (updated - more comprehensive)`);
                      enums[columnName] = values;
                    } else {
                      console.log(`  ‚ö†Ô∏è ${columnName}: [${values.join(', ')}] (skipped - less comprehensive)`);
                    }
                  } else {
                    enums[columnName] = values;
                    console.log(`  üìù ${columnName}: [${values.join(', ')}]`);
                  }
                }
              }
            }
          }
        });
      }
    }
  }
  
  // Also look for explicit enum definitions in the types
  const enumDefinitionMatches = typesContent.matchAll(/export\s+type\s+(\w+)\s*=\s*([^;]+);/g);
  for (const match of enumDefinitionMatches) {
    const [, enumName, typeDefinition] = match;
    
    if (typeDefinition.includes('|') && typeDefinition.includes('"')) {
      const values = [];
      const valueMatches = typeDefinition.matchAll(/"([^"]+)"/g);
      for (const valueMatch of valueMatches) {
        values.push(valueMatch[1]);
      }
      
      if (values.length > 1) {
        const normalizedName = enumName.toLowerCase().replace(/type$/, '');
        if (enums[normalizedName]) {
          if (values.length > enums[normalizedName].length) {
            console.log(`  üîÑ ${normalizedName}: [${values.join(', ')}] (updated from type definition)`);
            enums[normalizedName] = values;
          }
        } else {
          enums[normalizedName] = values;
          console.log(`  üìù ${normalizedName}: [${values.join(', ')}] (from type definition)`);
        }
      }
    }
  }
  
  console.log(`üìä Found ${Object.keys(enums).length} enum definitions`);
  
  // Read existing config or create basic template
  let config = {};
  if (fs.existsSync(configPath)) {
    console.log(`üìñ Reading existing config: ${configPath}`);
    config = yaml.load(fs.readFileSync(configPath, 'utf8'));
  } else {
    console.log(`üìÑ Creating new config: ${configPath}`);
    config = {
      supabase_url: process.env.SUPABASE_URL || 'YOUR_SUPABASE_URL',
      supabase_anon_key: process.env.SUPABASE_ANON_KEY || 'YOUR_SUPABASE_ANON_KEY',
      dart_format: true,
      output: '.',
      separated: true,
      dart_class: true,
      include_views: true,
      include_enums: true
    };
  }
  
  // Update enums section
  config.enums = enums;
  
  // Write updated config
  const configDir = path.dirname(configPath);
  if (!fs.existsSync(configDir)) {
    fs.mkdirSync(configDir, { recursive: true });
  }
  
  fs.writeFileSync(configPath, yaml.dump(config, {
    flowLevel: 2,
    quotingType: '"',
    forceQuotes: false
  }));
  
  console.log(`‚úÖ Updated Supadart config with ${Object.keys(enums).length} enum types`);
  console.log(`üìÅ Config saved to: ${configPath}`);
  
  return enums;
}

// CLI execution
if (require.main === module) {
  const typesFilePath = process.argv[2];
  const configPath = process.argv[3] || 'supadart.yaml';
  
  if (!typesFilePath) {
    console.error('Usage: node typescript-enum-parser.js <types-file> [config-path]');
    process.exit(1);
  }
  
  parseTypescriptEnums(typesFilePath, configPath)
    .then((enums) => {
      console.log('\nüéâ TypeScript enum parsing completed successfully!');
      console.log(`üìä Total enums: ${Object.keys(enums).length}`);
      process.exit(0);
    })
    .catch((error) => {
      console.error('\nüí• TypeScript enum parsing failed:', error.message);
      process.exit(1);
    });
}

module.exports = { parseTypescriptEnums };