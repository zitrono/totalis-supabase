
// Totalis Types v1.0.999
// Generated: 2025-06-01T14:24:39.122Z
// DO NOT EDIT - This file is automatically generated

// Database Enums


// Database Models


// Database Views


// Edge Function Types
class UserContext {
  final String userId;
  final String coachId;
  final String recentCategories;
  final List<dynamic> checkInHistory;
  UserContext({
    required this.userId,
    required this.coachId,
    required this.recentCategories,
    required this.checkInHistory,
  });
  factory UserContext.fromJson(Map<String, dynamic> json) => UserContext(
        userId: json['userId'],
        coachId: json['coachId'],
        recentCategories: json['recentCategories'],
        checkInHistory: json['checkInHistory'],
      );
  Map<String, dynamic> toJson() => {
        'userId': userId,
        'coachId': coachId,
        'recentCategories': recentCategories,
        'checkInHistory': checkInHistory,
      };
}
class CheckIn {
  final String id;
  final String userId;
  final String categoryId;
  final dynamic status;
  final String startedAt;
  final String? completedAt;
  final List<dynamic>? responses;
  CheckIn({
    required this.id,
    required this.userId,
    required this.categoryId,
    required this.status,
    required this.startedAt,
    this.completedAt,
    this.responses,
  });
  factory CheckIn.fromJson(Map<String, dynamic> json) => CheckIn(
        id: json['id'],
        userId: json['userId'],
        categoryId: json['categoryId'],
        status: json['status'],
        startedAt: json['startedAt'],
        completedAt: json['completedAt'],
        responses: json['responses'],
      );
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'categoryId': categoryId,
        'status': status,
        'startedAt': startedAt,
        'completedAt': completedAt,
        'responses': responses,
      };
}
class Recommendation {
  final String? id;
  final String userId;
  final String title;
  final String insight;
  final String why;
  final String action;
  final String categoryId;
  final int importance;
  final String relevance;
  final String? createdAt;
  Recommendation({
    this.id,
    required this.userId,
    required this.title,
    required this.insight,
    required this.why,
    required this.action,
    required this.categoryId,
    required this.importance,
    required this.relevance,
    this.createdAt,
  });
  factory Recommendation.fromJson(Map<String, dynamic> json) => Recommendation(
        id: json['id'],
        userId: json['userId'],
        title: json['title'],
        insight: json['insight'],
        why: json['why'],
        action: json['action'],
        categoryId: json['categoryId'],
        importance: json['importance'],
        relevance: json['relevance'],
        createdAt: json['createdAt'],
      );
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'title': title,
        'insight': insight,
        'why': why,
        'action': action,
        'categoryId': categoryId,
        'importance': importance,
        'relevance': relevance,
        'createdAt': createdAt,
      };
}
class ChatMessage {
  final String? id;
  final String userId;
  final String message;
  final bool isUser;
  final String timestamp;
  final dynamic? contextType;
  final String? contextId;
  ChatMessage({
    this.id,
    required this.userId,
    required this.message,
    required this.isUser,
    required this.timestamp,
    this.contextType,
    this.contextId,
  });
  factory ChatMessage.fromJson(Map<String, dynamic> json) => ChatMessage(
        id: json['id'],
        userId: json['userId'],
        message: json['message'],
        isUser: json['isUser'],
        timestamp: json['timestamp'],
        contextType: json['contextType'],
        contextId: json['contextId'],
      );
  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'message': message,
        'isUser': isUser,
        'timestamp': timestamp,
        'contextType': contextType,
        'contextId': contextId,
      };
}
class AnalyticsSummary {
  final String userId;
  final dynamic period;
  final int totalCheckIns;
  final int completedCheckIns;
  final List<dynamic> topCategories;
  final int streakDays;
  final String insights;
  AnalyticsSummary({
    required this.userId,
    required this.period,
    required this.totalCheckIns,
    required this.completedCheckIns,
    required this.topCategories,
    required this.streakDays,
    required this.insights,
  });
  factory AnalyticsSummary.fromJson(Map<String, dynamic> json) => AnalyticsSummary(
        userId: json['userId'],
        period: json['period'],
        totalCheckIns: json['totalCheckIns'],
        completedCheckIns: json['completedCheckIns'],
        topCategories: json['topCategories'],
        streakDays: json['streakDays'],
        insights: json['insights'],
      );
  Map<String, dynamic> toJson() => {
        'userId': userId,
        'period': period,
        'totalCheckIns': totalCheckIns,
        'completedCheckIns': completedCheckIns,
        'topCategories': topCategories,
        'streakDays': streakDays,
        'insights': insights,
      };
}
class CategoryStat {
  final String categoryId;
  final String categoryName;
  final int count;
  final String lastUsed;
  CategoryStat({
    required this.categoryId,
    required this.categoryName,
    required this.count,
    required this.lastUsed,
  });
  factory CategoryStat.fromJson(Map<String, dynamic> json) => CategoryStat(
        categoryId: json['categoryId'],
        categoryName: json['categoryName'],
        count: json['count'],
        lastUsed: json['lastUsed'],
      );
  Map<String, dynamic> toJson() => {
        'categoryId': categoryId,
        'categoryName': categoryName,
        'count': count,
        'lastUsed': lastUsed,
      };
}
class TranscriptionBatchItem {
  final String id;
  final String? audio_url;
  final String? audio_base64;
  final String? language;
  final String? prompt;
  TranscriptionBatchItem({
    required this.id,
    this.audio_url,
    this.audio_base64,
    this.language,
    this.prompt,
  });
  factory TranscriptionBatchItem.fromJson(Map<String, dynamic> json) => TranscriptionBatchItem(
        id: json['id'],
        audio_url: json['audio_url'],
        audio_base64: json['audio_base64'],
        language: json['language'],
        prompt: json['prompt'],
      );
  Map<String, dynamic> toJson() => {
        'id': id,
        'audio_url': audio_url,
        'audio_base64': audio_base64,
        'language': language,
        'prompt': prompt,
      };
}
class BatchTranscriptionResult {
  final String id;
  final String text;
  final int? duration;
  final String? language;
  final String? error;
  BatchTranscriptionResult({
    required this.id,
    required this.text,
    this.duration,
    this.language,
    this.error,
  });
  factory BatchTranscriptionResult.fromJson(Map<String, dynamic> json) => BatchTranscriptionResult(
        id: json['id'],
        text: json['text'],
        duration: json['duration'],
        language: json['language'],
        error: json['error'],
      );
  Map<String, dynamic> toJson() => {
        'id': id,
        'text': text,
        'duration': duration,
        'language': language,
        'error': error,
      };
}
class CheckinQuestion {
  final String id;
  final String text;
  final int type;
  final String? options;
  final int? min;
  final int? max;
  final bool? required;
  CheckinQuestion({
    required this.id,
    required this.text,
    required this.type,
    this.options,
    this.min,
    this.max,
    this.required,
  });
  factory CheckinQuestion.fromJson(Map<String, dynamic> json) => CheckinQuestion(
        id: json['id'],
        text: json['text'],
        type: json['type'],
        options: json['options'],
        min: json['min'],
        max: json['max'],
        required: json['required'],
      );
  Map<String, dynamic> toJson() => {
        'id': id,
        'text': text,
        'type': type,
        'options': options,
        'min': min,
        'max': max,
        'required': required,
      };
}
class LangflowRequest {
  final String prompt;
  final String context;
  final dynamic type;
  LangflowRequest({
    required this.prompt,
    required this.context,
    required this.type,
  });
  factory LangflowRequest.fromJson(Map<String, dynamic> json) => LangflowRequest(
        prompt: json['prompt'],
        context: json['context'],
        type: json['type'],
      );
  Map<String, dynamic> toJson() => {
        'prompt': prompt,
        'context': context,
        'type': type,
      };
}
class TranscriptionRequest {
  final String? audio_url;
  final String? audio_base64;
  final String? language;
  final String? prompt;
  final String? message_id;
  final List<dynamic>? batch;
  TranscriptionRequest({
    this.audio_url,
    this.audio_base64,
    this.language,
    this.prompt,
    this.message_id,
    this.batch,
  });
  factory TranscriptionRequest.fromJson(Map<String, dynamic> json) => TranscriptionRequest(
        audio_url: json['audio_url'],
        audio_base64: json['audio_base64'],
        language: json['language'],
        prompt: json['prompt'],
        message_id: json['message_id'],
        batch: json['batch'],
      );
  Map<String, dynamic> toJson() => {
        'audio_url': audio_url,
        'audio_base64': audio_base64,
        'language': language,
        'prompt': prompt,
        'message_id': message_id,
        'batch': batch,
      };
}
class CheckinRequest {
  final dynamic action;
  final String? categoryId;
  final String? category_id;
  final String? checkinId;
  final String? checkin_id;
  final String? questionId;
  final String? question_id;
  final Map<String, dynamic>? answer;
  final Map<String, dynamic>? proposals;
  CheckinRequest({
    required this.action,
    this.categoryId,
    this.category_id,
    this.checkinId,
    this.checkin_id,
    this.questionId,
    this.question_id,
    this.answer,
    this.proposals,
  });
  factory CheckinRequest.fromJson(Map<String, dynamic> json) => CheckinRequest(
        action: json['action'],
        categoryId: json['categoryId'],
        category_id: json['category_id'],
        checkinId: json['checkinId'],
        checkin_id: json['checkin_id'],
        questionId: json['questionId'],
        question_id: json['question_id'],
        answer: json['answer'],
        proposals: json['proposals'],
      );
  Map<String, dynamic> toJson() => {
        'action': action,
        'categoryId': categoryId,
        'category_id': category_id,
        'checkinId': checkinId,
        'checkin_id': checkin_id,
        'questionId': questionId,
        'question_id': question_id,
        'answer': answer,
        'proposals': proposals,
      };
}
class TTSRequest {
  final String text;
  final String? voice;
  final String? model;
  final int? speed;
  final String? response_format;
  TTSRequest({
    required this.text,
    this.voice,
    this.model,
    this.speed,
    this.response_format,
  });
  factory TTSRequest.fromJson(Map<String, dynamic> json) => TTSRequest(
        text: json['text'],
        voice: json['voice'],
        model: json['model'],
        speed: json['speed'],
        response_format: json['response_format'],
      );
  Map<String, dynamic> toJson() => {
        'text': text,
        'voice': voice,
        'model': model,
        'speed': speed,
        'response_format': response_format,
      };
}
class CheckInResponse {
  final String questionId;
  final String question;
  final String answer;
  final String timestamp;
  CheckInResponse({
    required this.questionId,
    required this.question,
    required this.answer,
    required this.timestamp,
  });
  factory CheckInResponse.fromJson(Map<String, dynamic> json) => CheckInResponse(
        questionId: json['questionId'],
        question: json['question'],
        answer: json['answer'],
        timestamp: json['timestamp'],
      );
  Map<String, dynamic> toJson() => {
        'questionId': questionId,
        'question': question,
        'answer': answer,
        'timestamp': timestamp,
      };
}
class LangflowResponse {
  final Map<String, dynamic> result;
  final String? metadata;
  LangflowResponse({
    required this.result,
    this.metadata,
  });
  factory LangflowResponse.fromJson(Map<String, dynamic> json) => LangflowResponse(
        result: json['result'],
        metadata: json['metadata'],
      );
  Map<String, dynamic> toJson() => {
        'result': result,
        'metadata': metadata,
      };
}
class TranscriptionResponse {
  final String text;
  final int? duration;
  final String? language;
  final String? error;
  final String? message_id;
  final List<dynamic>? batch_results;
  TranscriptionResponse({
    required this.text,
    this.duration,
    this.language,
    this.error,
    this.message_id,
    this.batch_results,
  });
  factory TranscriptionResponse.fromJson(Map<String, dynamic> json) => TranscriptionResponse(
        text: json['text'],
        duration: json['duration'],
        language: json['language'],
        error: json['error'],
        message_id: json['message_id'],
        batch_results: json['batch_results'],
      );
  Map<String, dynamic> toJson() => {
        'text': text,
        'duration': duration,
        'language': language,
        'error': error,
        'message_id': message_id,
        'batch_results': batch_results,
      };
}
class TTSResponse {
  final String? audio_url;
  final String? audio_base64;
  final int? duration_estimate;
  final String? error;
  TTSResponse({
    this.audio_url,
    this.audio_base64,
    this.duration_estimate,
    this.error,
  });
  factory TTSResponse.fromJson(Map<String, dynamic> json) => TTSResponse(
        audio_url: json['audio_url'],
        audio_base64: json['audio_base64'],
        duration_estimate: json['duration_estimate'],
        error: json['error'],
      );
  Map<String, dynamic> toJson() => {
        'audio_url': audio_url,
        'audio_base64': audio_base64,
        'duration_estimate': duration_estimate,
        'error': error,
      };
}

// Utilities
class DateTimeUtils {
  static DateTime fromJson(String json) => DateTime.parse(json);
  static String toJson(DateTime object) => object.toIso8601String();
  
  static DateTime? fromJsonNullable(String? json) => 
    json != null ? DateTime.parse(json) : null;
  static String? toJsonNullable(DateTime? object) => object?.toIso8601String();
}

// Version info
const String totalisTypesVersion = '1.0.999';
const String generatedAt = '2025-06-01T14:24:39.123Z';
